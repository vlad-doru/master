%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass{beamer}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[romanian]{babel}
\usepackage{amsmath}
\usepackage{listings}



\mode<presentation> {

\usetheme{Frankfurt}
\usecolortheme{dolphin}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Cuckoo Hashing]{Algoritmi de hashing de complexitate O(1) Cuckoo Hashing} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Vlad-Doru Ion} % Your name
\institute[UNIBUC] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Universitatea din București \\ % Your institution for the title page
\medskip
}
\date{\today} % Date, can be changed to a custom date

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}
\frametitle{Overview} % Table of contents slide, comment this block out to remove it
\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------
\section{Introducere}
%------------------------------------------------

\begin{frame}
\frametitle{Introducere}
\begin{itemize}
\item Cuckoo Hashing reprezintă un algoritm de hashing ce a fost descris de Rasmus Pagh și Flemming Friche Rodler în Ianuarie 2002.
\item Cuckoo Hashing descrie construcția unei tabele de dispersie ce permite regăsirea informației în timp O(1).
\item În ceea ce privește spațiul folosit de algoritm acesta este apropiat de cel folosit de arborii binari de căutare.
\item Spre deosebire de algoritmul de hashing dinamic perfect, propus de Dietzfelbinger, a cărui performanță o egalează, Cuckoo hashing propune o implementare elegantă și utilă în scopuri practice.
\end{itemize}

\end{frame}

%------------------------------------------------
\subsection{Obiective}

\begin{frame}
\frametitle{Obiective}
\begin{itemize}
\item Complexitatea timp a operației de căutare: $\mathcal{O}(1)$
\item Complexitatea timp a operației de inserare: $\mathcal{O}(1)$ amorizat \footnote{Complexitatea amoritzată ia în considerare o secvență de operații, asigurându-se astfel că cele cu o complexitate ridicată au o frecvență scazută.}
\item Spațiu utilizat de tabelel de disperise: $\approx 2n$
\end{itemize}

\begin{block}{Ideea centrală}
În loc de a alege abordarea clasică, în care algoritmii folosesc o singură funcție de hashing, se vor folosi două funcții de hashing. Astfel, fiecare cheie se va putea afla la doar una din cele două locații indicate de funcțiile alese. 
\end{block}

Datorită faptului că cele două funcții de hashing sunt independente, accesul la memorie poate fi făcut în mod paralel îmbunătățind performanță practică a algoritmului.

\end{frame}
%------------------------------------------------
\subsection{Preliminarii}

\begin{frame}
\frametitle{Preliminarii}
\begin{itemize}
\item Vom considera cheile ca aparținând unei mulțimi $U = {0,1}^w$, unde $w$ reprezintă dimensiunea cuvântului asociat procesorului. În general cheile vor fi elemente întregi reprezentate pe 32 de biți.
\item Dacă unei chei nu îi corespunde nicio valoare atunci vom nota acest lucru prin simbolul $\bot$.
\item Algoritmul va folosi cele două funcții de hash alese dintr-o \textit{familie universală}.
\begin{definition}[Familie universală de funcții de hashing]
O familie  $h_i, i \in I, h_i:D \to E$  este universală dacă, $\forall k > 0, \forall x_1, x_2 ..., x_k \in U \text{ distincte}, \forall y_1, ..., y_k \in E,$ și $i$ ales uniform peste $I: Pr[h_i(x1) = y1, ..., h_i(x_k) = y_k] \leq \frac{c}{|E|^k}$
\end{definition}
\end{itemize}

\end{frame}
%------------------------------------------------
\section{Algoritmul}

\begin{frame}
\frametitle{Descrierea algoritmului}
\begin{itemize}
\item Vom folosi două tabele de dispersie, $T1$ și $T2$, de dimensiuni identice. Vom nota dimensiunea acestora cu $r$.
\item Vom folosi două funcții de hash, $h_1, h_2: U \to \{0, 1, ..., r-1\}$.
\begin{block}{Stocarea cheilor}
Fiecare cheie $x$ se va afla fie în celula cu indicele $h1(x)$ al tabelei $T1$, fie în celula cu indicele $h2(x)$ al tabele $T2$, \textbf{dar niciodată în ambele tabele}.
\end{block}
\end{itemize}

\end{frame}
%------------------------------------------------
\begin{frame}[fragile]
\frametitle{Căutarea și ștergerea unei chei}
\begin{itemize}
\item După cum am menționat anterior, o cheie nu se poate afla decât în cele mult unul din tabelele $T1$ și $T2$.
\begin{block}{Funcția de căutare}
Funcția de căutare este una trivială astfel:
\lstset{language = Python, 
        showstringspaces=false,
        keywordstyle=\color{blue},
        }
\begin{lstlisting}
  def lookup(x):
   	return T1[h1(x)] == x or T2[h2[x]] == x
\end{lstlisting}
\end{block}
\item Este evident că avem o complexitate timp $\mathcal{O}(1)$, întrucât efectuăm două operații de acces la memorie ce se produc în timp constant.
\item Pentru ștergerea unei chei putem presupune fară pierderea generalității ca avem o cheie $x$ ce se află în tabelul $T1$. Atunci vom șterge cheia x prim marcarea poziției $h_1(x)$ din T1 ca fiind nefolosita: $T1[h_1(x)] := \bot$
\end{itemize}

\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Inserarea unei chei}
\begin{itemize}
\item Vom presupune ca va trebui sa inserăm cheia $x$. Deoarece ea nu poate fi pusă decât la una din pozițiile menționate anterior trebuie găsită o strategie de inserare.
\begin{block}{Mecanismul de inserare.}


\begin{description}
  \item[Cazul 1] Dacă $T1[h_1(x)] == \bot$ atunci inserăm cheia $x$ la poziția $h1(x)$. STOP.
  \item[Cazul 2] Dacă $T1[h_1(x)] == y$ atunci inserăm cheia $x$ la poziția $h1(x)$. Iterăm prin a insera cheia $y$ în tabelul T2 folosind același raționament.
\end{description}
\end{block}

\item \textit{Observație:} Există posibilitatea de a intra într-un ciclu folosind mecanismul de inserare. De aceea numărul de iterații va fi mărginit de o constantă superioară.
\item În momentul în care constanta este atinsă vom alege două noi funcții de hashing și vom reinsera toate cheile.
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Inserarea unei chei}
\begin{itemize}
\item În figura de mai jos putem vedea o ilustrare grafică a modului în care se inserează o cheie $x$. În partea stangă se poate observa structura înainte de inserare, iar în partea dreaptă după 

\begin{figure}
\includegraphics[width=0.4\linewidth]{cuckoo.jpg}
\end{figure}

\item Săgețile din fiecare cheie reprezintă pozițiile corespunzătoare acestora în tabelele T1 și T2.
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}[fragile]
\frametitle{Inserarea unei chei}
\begin{block}{Funcția de inserare}
\lstset{language = Python, 
        showstringspaces=false,
        basicstyle=\ttfamily\small,
        keywordstyle=\color{blue},
        }
\begin{lstlisting}
  def insert(x):
  	# Verificam daca cheia exista deja.
  	if lookup(x):
  		return
   	for i in range(MaxLoop):
   	  T1[h1[x]], x = x, T1[h1[x]]
   	  if x == None:
   	    return
   	  T2[h2[x]], x = x, T2[h2[x]]
   	  if x == None:
   	    return
   	# Daca nu am putut face inserarea
   	rehash()
   	insert(x)
\end{lstlisting}
\end{block}

\end{frame}
%------------------------------------------------

\begin{frame}
\frametitle{Table}
\begin{table}
\begin{tabular}{l l l}
\toprule
\textbf{Treatments} & \textbf{Response 1} & \textbf{Response 2}\\
\midrule
Treatment 1 & 0.0003262 & 0.562 \\
Treatment 2 & 0.0015681 & 0.910 \\
Treatment 3 & 0.0009271 & 0.296 \\
\bottomrule
\end{tabular}
\caption{Table caption}
\end{table}
\end{frame}

%------------------------------------------------
\begin{frame}
\frametitle{Referințe}
\footnotesize{
\begin{thebibliography}{99} % Beamer does not support BibTeX so references must be inserted manually as below
\bibitem[cuckoo]{p1} John Smith (2012)
\newblock Cuckoo Hashing
\newblock \emph{Journal of Algorithms} 51(2004), 122 -- 144.
\end{thebibliography}
}
\end{frame}

%------------------------------------------------

\begin{frame}
\Huge{\centerline{Mulțumesc}}
\end{frame}

%----------------------------------------------------------------------------------------

\end{document} 